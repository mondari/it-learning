## Redis 特点

单线程 + IO多路复用

“IO多路复用”参见 [Java IO.md](Java IO.md)

IO多路复用，是通过一个线程来轮询多个 Socket，只有当 Socket 有读写事件时，才会通知程序进行 IO 读写操作。因此IO多路复用比较适合连接数比较多的情况。

## Redis 的数据结构及其使用场景

Redis 支持5种数据结构：

1. string 字符串：普通的键值对数据
2. list 双向链表：消息队列、评论列表、时间轴数据
3. set 集合：适合存储需要去重的数据。Redis 非常人性化的为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同好友、共同关注、共同爱好的功能
4. zset 有序集合：适合存储排行榜相关的数据，比如商品销量排行榜、成绩排行榜、积分排行榜（key 设置为“积分排行榜”，value 设置为“id”，score 设置为“积分”
5. hash 字典：关联性强的键值对数据，用户信息（key 设置为“用户信息”，hkey 设置为”姓名“，hval 设置为”张三“）

## Redis 集群搭建

参考：https://blog.csdn.net/qq_42815754/article/details/82912130

Redis集群至少需要3个节点，因为投票容错机制要求超过半数节点认为某个节点挂了该节点才是挂了，所以2个节点无法构成集群

为了保障高可用，需要每个节点都要有个备用节点，所以之前需要6个节点才能组成一个高可用集群

Redis没有中心节点，节点之间使用PING-PONG机制进行通信

如何判断集群是否挂了呢? 如果集群中任意一个节点挂了，而且该节点没有从节点（备份节点），那么这个集群就挂了。

每个Redis集群理论上最多支持有16384个节点（即2的14次方个节点）



## 缓存穿透

大量查询不存在value的key

查询一个根本不存在的数据，缓存层和存储层都不会命中，这样就会导致每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。



**解决方案**：

1. 存空值

   存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，保护了后端存储。

   **缺点**

   1. 需要更多的内存空间（解决方法：设置过期时间）
   2. 缓存层和存储层会有一段时间的数据不一致（万一数据库中新增了对应的数据，就会导致不一致）

2. 布隆过滤器

   将数据库中所有的数据的key，放入布隆过滤器中，当一个查询请求过来时，先经过布隆过滤器进行查询，如果不存在，则直接返回空；存在，则继续查；

   Redis 使用布隆过滤器伪代码：

   - 先查布隆过滤器 => 再查 Redis => 最后查数据库

   ```java
   String get(String key) {
   
       // 1.先查布隆过滤器
       if (!bloomFilter.mightContain(key)) {
           return null;
       } else {
           // 2.再查 Redis
           String value = redis.get(key);
           if (value == null) {
               // 3.最后查数据库
               value = db.get(key);
               redis.set(key, value);
           }
           return value;
       }
   
   }
   ```

   - 先查 Redis => 再查布隆过滤器 => 布隆过滤器存在则查数据库

   ```java
   String get(String key) {
       // 1.先查 Redis
       String value = redis.get(key);
       if (value == null) {
           // 2.再查布隆过滤器
           if (!bloomFilter.mightContain(key)) {
               return null;
           } else {
               // 3. 布隆过滤器存在则查数据库
               value = db.get(key);
               redis.set(key, value);
           }
       }
       return value;
   }
   ```

   

   **缺点**

   1. 需要另外维护一个集合来存放缓存的Key
   2. 布隆过滤器不支持删值操作
   3. 代码复杂度增大

   **参考**

   https://www.cnblogs.com/rinack/p/9712477.html



## 缓存击穿|缓存并发

高并发的情况下，**某个缓存**失效的瞬间，会有大量线程来重建缓存，数据库压力剧增。

解决方案：

1. 加锁：只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完后，重新从缓存获取数据即可。有死锁的风险。
2. 设置缓存永不过期。逻辑上会过期，会让一个线程异步去重建缓存，缓存重建完之前输出旧值，缓存重建完之后输出新值。



## 缓存雪崩

在某一时刻发生**大量缓存**同时失效（过期或宕机），会有大量请求走向数据库，导致数据库压力剧增甚至挂掉。

注意：

- 和**缓存击穿|缓存并发**区分开，缓存雪崩是**大量缓存**失效，而缓存击穿|缓存并发是**某个缓存**失效

解决方案：

- 分散缓存的过期时间。将缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。
- 使用主从备份+哨兵模式保障高可用，避免全盘崩溃
- 服务内部使用 Ehcache 本地缓存 + Hystrix 限流降级方案，保护后端数据库
- Redis 开启持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据

**参考**

https://doocs.gitee.io/advanced-java/#/./docs/high-concurrency/redis-caching-avalanche-and-caching-penetration

[阿里一面：关于【缓存穿透、缓存击穿、缓存雪崩、热点数据失效】问题的解决方案](https://mp.weixin.qq.com/s/5MloHIa5zKvYYsVVEWZjQA)

## 缓存不一致

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，**先删除缓存，再更新数据库**，防止先更新数据库后，再删除缓存时失败，导致数据不一致的问题（其实这可以加个事务来解决，当删除缓存时失败，则回滚数据库。所以这两步谁先谁后都没有问题）。



### 先删除缓存，再更新数据库

1. **高并发情况下的数据不一致的问题如何解决？**

   使用双删策略来解决：

| 步骤 | Thread-1（更新缓存） | Thread-2（读请求） |
| ---- | -------------------- | ------------------ |
| 1    | 删除缓存             |                    |
| 2    |                      | 读缓存->读数据库   |
| 3    | 更新数据库           |                    |
| 4    |                      | 写缓存             |
| 5    | **删除缓存（MQ）**   |                    |

2. **为什么是删除缓存（第5步），而不是更新缓存？**

- 因为在某些场景，缓存不单单是数据库中直接取出来的值，而是需要进行比较复杂的计算才能得到。

- 另外，也无法知道这个缓存是否会被频繁访问到。在用到缓存时才去算缓存可以有效降低开销。

所以在用到缓存时才会去计算缓存。



参考：

https://doocs.gitee.io/advanced-java/#/./docs/high-concurrency/redis-consistence

https://github.com/doocs/advanced-java/issues/54



### 先更新数据库，再删除缓存

为了防止在先更新数据库后，再删除缓存时失败，导致数据不一致的问题，我们可以加个事务，在删除缓存失败时，回滚数据库的操作，这样就不会导致数据不一致了。

但无论更新数据库和删除缓存，哪个先，哪个后，高并发的场景下都会出现问题，最后还是要通过双删策略来解决问题。

| 步骤 | Thread-1（更新缓存） | Thread-2（读请求） | Thread-3（更新缓存） |
| ---- | -------------------- | ------------------ | -------------------- |
| 1    | 更新数据库+删除缓存  |                    |                      |
| 2    |                      | 读缓存->读数据库   |                      |
| 3    |                      |                    | 更新数据库+删除缓存  |
| 4    |                      | 写缓存             |                      |
| 5    |                      |                    | **删除缓存（MQ）**   |



参考：

[漫画：要跳槽？这道缓存设计题你有必要看看！](https://mp.weixin.qq.com/s/JAzzrzFjMsOadCzeQUOB2w)

## 布隆过滤器原理、场景、使用

**应用场景**

1. 解决缓存穿透
2. 推荐去重

**实现原理**

布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：

![img](面试题%20-%20Redis.assets/2785001-07e149c32a2608fa.jpg)

当我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，和数组大小取模得到多个下标，对应下标的 bit 位置1。如果我们要查询一个值是否存在，通过哈希函数计算得到多个下标，如果所有下标的 bit 位都为1，则代表这个数据**可能存在**。

为什么是可能存在呢？这是因为随着我们往布隆过滤器添加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值即使没有被添加过，但是哈希函数返回下标所在的 bit 位可能都已经被其他值置为 1 了，布隆过滤器还是会判断为存在，但实际上这个值是并没有添加过的。

需要注意的是，布隆过滤器不支持删除操作。

参考：[详解布隆过滤器的原理、使用场景和注意事项](https://www.jianshu.com/p/2104d11ee0a2)



**使用布隆过滤器示例**

google guava 中有布隆过滤器 BloomFilter

```java
import com.google.common.hash.BloomFilter;
import com.google.common.hash.Funnels;
import java.util.ArrayList;
import java.util.List;

public class Test {

    private static int size = 1000000;

    private static BloomFilter<Integer> bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size);

    public static void main(String[] args) {
        for (int i = 0; i < size; i++) {
            bloomFilter.put(i);
        }

        List<Integer> list = new ArrayList<>(1000);
        //故意取10000个不在过滤器里的值，看看有多少个会被认为在过滤器里
        for (int i = size + 10000; i < size + 20000; i++) {
            if (bloomFilter.mightContain(i)) {
                list.add(i);
            }
        }
        // 该布隆过滤器默认的误判率为0.03
        System.out.println("误判的数量：" + list.size());
        // 说明布隆过滤器中存在，并不代表真的存在，有可能实际上并不存在。
    }

}

```

