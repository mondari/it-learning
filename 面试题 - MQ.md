[TOC]



## 什么是消息队列？

消息队列是存放消息的容器，我们想消费消息的时候就从中取，因为队列是一种 FIFO 的数据结构，所以我们取消息也是按照 FIFO 的顺序。消息队列主要用来削峰和解耦。

## 为什么要用消息队列？

消息队列主要有两个作用，一是削峰，二是解耦。（有人会说还有异步呢？我感觉削峰里面就包含了异步。）



**削峰**

- 不使用消息队列的请求方式是这样的：

发送请求-->后台处理-->返回结果（成功或失败）

因为服务器处理请求的能力是有限的，如果大量请求发过来，超过服务器的处理能力，前面请求没有处理完，而后面又有请求发过来，服务器的响应就会变慢，甚至崩溃。

- 使用消息队列的请求方式是这样的：

发送请求-->消息队列-->响应请求（告诉用户正在处理中，请稍候）
消息队列-->后台处理-->保存数据，通知结果（成功或失败）

使用消息队列可以异步地处理请求。当用户请求发过来，先保存到消息队列，然后后端直接响应请求，告诉用户正在处理中，请稍候。后端根据处理能力从消息队列中消息消息，当真正处理完并数据库保存数据后，通过邮件、短信或者消息推送通知用户即可。



**解耦**

模块之间不存在直接的调用关系，新增模块不影响现有模块，或者新增和修改模块对其它模块改动小，这样的系统耦合度会很低、扩展性会很高，大家都喜欢，因为工作量降低了呀。

消息队列使用发布-订阅模式工作，消息生产者发布消息，消息消费者订阅消息，两者之间没有直接耦合。那么新增模块业务如果要用到现有模块的消息，只需要订阅即可，无需改动现有模块，从而达到解耦。

## 消息队列带来的问题

- **系统可用性降低：** 需要考虑 MQ 挂了的情况。
- **系统复杂性提高：** 需要解决消息丢失、加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等各种各样的问题。
- **一致性问题：** 消息没有被真正的消费者消费，就会出现数据不一致的情况。

## 如何选择消息队列？

- RocketMQ 和 Kafka

  分布式架构，高可用，吞吐量很高，毫秒级别延迟，适合实时计算以及日志收集

- RabbitMQ

  基于主从架构实现高可用，并发能力很强，微秒级别延迟（处理十万、百万级别请求面不改色心不跳），适合吞吐量不高的场景，但是基于 erlang 开发，定制能力低。

## 如何解决RabbitMQ消息丢失的问题？

从三个方面解决这个问题：

1. 生产者**开启 Confirm 模式**，确保消息成功发送到队列（RabbitTemplate 设置 ConfirmCallback 和 ReturnCallback）
2. 开启持久化，确保MQ挂了消息不丢失。

   - Exchange 交换机持久化：new DirectExchange(“name”, true);
   - 队列持久化：new Queue(“name”, true);
   - 消息持久化：`deliveryMode` 设为2。默认就是持久化的
3. 消费者手动 ACK 确认消费正确消息：关闭消费者自动 ACK 确认功能

参考：

[如何保证消息的可靠性传输？（如何处理消息丢失的问题）](https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages.md)

[RabbitMQ：消息发送确认 与 消息接收确认（ACK）]()

[RabbitMQ之消息持久化](https://blog.csdn.net/u013256816/article/details/60875666)



## 设计一个分布式订单系统

要求优先级高的订单优先处理，并保证任意时刻一个订单不会被重复处理，该如何设计？

答：每次请求进来，都把要处理的订单存到优先级队列里，消费者只需要监听消费队列中的订单即可。

RabbitMQ 优先级队列注意点：只有当消费者不足，不能及时进行消费的情况下，优先级队列才会生效

