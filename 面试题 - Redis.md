[TOC]

## Redis 集群搭建

参考：https://blog.csdn.net/qq_42815754/article/details/82912130

Redis集群至少需要3个节点，因为投票容错机制要求超过半数节点认为某个节点挂了该节点才是挂了，所以2个节点无法构成集群

为了保障高可用，需要每个节点都要有个备用节点，所以之前需要6个节点才能组成一个高可用集群

Redis没有中心节点，节点之间使用PING-PONG机制进行通信

如何判断集群是否挂了呢? 如果集群中任意一个节点挂了，而且该节点没有从节点（备份节点），那么这个集群就挂了。

每个Redis集群理论上最多支持有16384个节点（即2的14次方个节点）

## 缓存失效、缓存并发、缓存穿透、缓存雪崩

**缓存失效**：在高并发的情况下可能会出在某一个时刻同时生成了很多的缓存，并且过期时间都一样，当过期时间到后，这些缓存就会同时失效，请求全部转发到数据库，数据库的压力就会剧增。

解决方案：将缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。



**缓存并发**：高并发的情况下，缓存失效的瞬间，会有大量线程来重建缓存，数据库压力剧增。

解决方案：

1. 加锁：只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完后，重新从缓存获取数据即可。有死锁的风险。
2. 设置缓存永不过期。逻辑上会过期，会让一个线程异步去重建缓存，缓存重建完之前输出旧值，缓存重建完之后输出新值。



**缓存穿透**：查询一个根本不存在的数据，缓存层和存储层都不会命中，这样就会导致每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。

解决方案：存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，保护了后端存储。

缺点：

1. 需要更多的内存空间
2. 缓存层和存储层会有一段时间的数据不一致



**缓存雪崩**：缓存不可用导致高并发请求走向数据库，导致数据库压力剧增甚至挂掉

解决方法：

1. 搭建Redis，使用主从备份+哨兵模式保障高可用
2. 使用熔断进行限流

## 设计一个分布式订单系统

要求优先级高的订单优先处理，并保证任意时刻一个订单只被一个线程处理，订单的数据结构该如何设计，该使用什么样的存储？

答：将要处理的订单通通存到优先级队列里，要处理的时候取出，并将其订单号存到 Redis 中作为分布式锁，保证任意时刻一个订单只能被一台机器的一个线程处理。